#!/usr/bin/python3

'''
siapp-sdk

SPDX-License-Identifier: MIT
Copyright 2022 Siemens AG

Author:
Armin Tirala <armin.tirala@siemens.com>

'''

import os
import shutil
import tarfile
import json
import subprocess
import pathlib
from time import sleep
import uuid
import datetime

from helper import (BuildArgs, Platform, error_handler, parse_arguments,
                    run_subprocess, remove_container, warning,
                    init_multiarch_qemu)


def _max_rootfs_size_in_mb():
    return 350


def _copy_if_exists(src, dst):
    if os.path.exists(src):
        shutil.copytree(src, dst)


def _initialize_directory(dir):
    tmp_dir = os.path.join(dir, 'tmp')
    if os.path.exists(tmp_dir):
        shutil.rmtree(tmp_dir, ignore_errors=False)

        # required, because the rmtree subprocess may be too slow
        while os.path.exists(tmp_dir):
            print(f"Info: Waiting for directory {dir} to be deleted")
            sleep(1)
            pass

    os.makedirs(os.path.join(tmp_dir, 'meta-inf.pmf'))
    os.makedirs(os.path.join(tmp_dir, 'siapp'))
    os.makedirs(os.path.join(tmp_dir, 'out'))


def _byte_to_mb(size):
    return int((size / 1024 / 1024) + 1)


def _recommended_siapp_slot_size_in_mb(size):
    return int(((size / 7 / 1024 / 1024) * 10) + 31)


def _create_rootfs_container(src_dir, build_dir, container_name, version,
                             platform: Platform):
    '''
    Creates  the rootfs container based on the container file.
    '''

    container_file = os.path.join(src_dir, "Dockerfile")
    container_image = f"{container_name}-{version}"
    tar_file = os.path.join(build_dir, 'tmp', 'siapp', 'rootfs.tar')

    if not os.path.exists(container_file):
        error_handler(f"File does not exist: {container_file}")

    command_list = [BuildArgs.tool, 'build', '--platform',
                    platform.image,
                    '-f', container_file, '-t', container_image, src_dir]
    result = run_subprocess(command_list)
    if result.returncode != 0:
        error_handler("Could not build docker image!")

    command_list = [BuildArgs.tool, 'create', '--name', container_name,
                    '--platform',  platform.image,
                    container_image]
    result = run_subprocess(command_list)
    if result.returncode != 0:
        remove_container(container_name, True)
        error_handler("Could not create docker container!")
    command_list = [BuildArgs.tool, 'export', '--output=' + tar_file,
                    container_name]
    result = run_subprocess(command_list)
    if result.returncode != 0:
        remove_container(container_name, True)
        error_handler("Could not export root filesystem out of "
                      "docker container!")
    file_size = os.path.getsize(tar_file)

    return file_size


def _create_oci_file(project_path, build_dir, container_name):
    '''
    Creates the config.json file. If the file does not exist in the project,
    directory use the template file.
    '''
    config_file = os.path.join(project_path, 'config.json')
    common_config_file = os.path.join(pathlib.Path(__file__).parent.resolve(),
                                      'templates', 'config.json')
    temp_config_file = os.path.join(build_dir, 'tmp', 'siapp', 'config.json')

    if os.path.exists(config_file):
        with open(config_file, 'r') as f:
            config_json = json.load(f)
    else:
        print(f'Info: OCI file {config_file} not found. OCI file is generated by template file!')
        with open(common_config_file, 'r') as f:
            config_json = json.load(f)

    command_output = subprocess.check_output([BuildArgs.tool, 'inspect',
                                              container_name])
    output_str = command_output.decode('utf-8')
    json_start_index = output_str.find('[')
    json_data = output_str[json_start_index:]
    container_json = json.loads(json_data)[0]

    config_json['process']['args'] = []
    config_json['root']['path'] = 'rootfs'

    if container_json.get('Config', False):
        config_obj = container_json['Config']
        if config_obj.get('Entrypoint', False):
            if config_obj['Entrypoint']:
                if isinstance(config_obj['Entrypoint'], list):
                    config_json['process']['args'].extend(
                        config_obj['Entrypoint'])
                else:
                    config_json['process']['args'].append(
                        config_obj['Entrypoint'])
        if config_obj.get('Cmd', False):
            if isinstance(config_obj['Cmd'], list):
                config_json['process']['args'].extend(config_obj['Cmd'])
            else:
                config_json['process']['args'].append(config_obj['Cmd'])
        if config_obj.get('Env', False):
            config_json['process']['env'] = config_obj['Env']
        if config_obj.get('WorkingDir', False):
            config_json['process']['cwd'] = config_obj['WorkingDir']

    if len(config_json['process']['args']) == 0:
        error_handler("Could not find ENTRYPOINT OR CMD in Dockerfile")

    if len(config_json['process']['args']) == 1 and config_json['process']['args'][0] == "/bin/sh":
        warning(f"Could not find a valid ENTRYPOINT or CMD option in Dockerfile")

    with open(temp_config_file, 'w', newline='\r\n') as f:
        json.dump(config_json, f, indent=4)


def _create_meta_info_file(
        build_dir, container_name, size, platform: Platform):
    date = datetime.datetime.now()
    command_output = subprocess.check_output([BuildArgs.tool, 'inspect',
                                              container_name])
    output_str = command_output.decode('utf-8')
    json_start_index = output_str.find('[')
    json_data = output_str[json_start_index:]
    container_json = json.loads(json_data)[0]

    pim_pid_file = os.path.join(build_dir, 'tmp', 'meta-inf.pmf', 'pim.pid')

    pim_pid = f'ies_pkgname={BuildArgs.name}\n'
    pim_pid += f'ies_pkgid={uuid.uuid4()}\n'
    pim_pid += f'ies_pkgrev={BuildArgs.version}\n'
    pim_pid += f'ies_pkgtype=SIAPP\n'
    pim_pid += f'ies_pkgarch={platform.arch}\n'
    pim_pid += f'ies_pkgrootfs_size_mb={_byte_to_mb(size)}\n'
    pim_pid += f'ies_pkgcontainerid={container_json["Id"]}\n'
    pim_pid += f'ies_pkgimageid={container_json["Image"]}\n'

    # BUG SICAM Device Manager 4.70 workaround
    # pim_pid += 'ies_pkgbuildtime=\"' + date.strftime("%d.%m.%Y  %H:%M") + '\"\n'
    pim_pid += 'ies_pkgbuildtime=' + date.strftime("%d.%m.%Y  %H:%M")+ '\n'

    with open(pim_pid_file, 'w', newline='\r\n') as f:
        f.write(pim_pid)


def _package_siapp(dir, container_name):
    out_dir = os.path.join(dir, 'tmp', 'out')
    scr_dir = os.path.join(dir, 'tmp')

    with tarfile.open(os.path.join(out_dir, 'meta-inf.pmf'), "w:", format=tarfile.GNU_FORMAT) as tar:
        tar.add(os.path.join(scr_dir, 'meta-inf.pmf'), arcname='')

    with tarfile.open(os.path.join(out_dir, 'siapp.tar.gz'), "w:gz", format=tarfile.GNU_FORMAT) as tar:
        tar.add(os.path.join(scr_dir, 'siapp'), arcname='')

    if os.path.exists(os.path.join(scr_dir, 'cmd')):
        with tarfile.open(os.path.join(out_dir, 'cmd.tar.gz'), "w:gz", format=tarfile.GNU_FORMAT) as tar:
            tar.add(os.path.join(scr_dir, 'cmd'), arcname='')
        os.rename(os.path.join(out_dir, 'cmd.tar.gz'), os.path.join(out_dir, 'cmd.tgz'))

    if os.path.exists(os.path.join(scr_dir, 'app-doc')):
        with tarfile.open(os.path.join(out_dir, 'app-doc.tar.gz'), "w:gz", format=tarfile.GNU_FORMAT) as tar:
            tar.add(os.path.join(scr_dir, 'app-doc'), arcname='')
        os.rename(os.path.join(out_dir, 'app-doc.tar.gz'), os.path.join(out_dir, 'app-doc.tgz'))

    with tarfile.open(os.path.join(dir, container_name + '.siapp'), "w:", format=tarfile.GNU_FORMAT) as tar:
        tar.add(out_dir, arcname='')

    file_size = os.path.getsize(os.path.join(dir, container_name + '.siapp'))

    return file_size


def _print_result(siapp_size, rootfs_size, siapp):
    name = os.path.basename(__file__)

    print(f"{name} - ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
    print(f"{name} - Size of unzipped root file system:                  {_byte_to_mb(rootfs_size):>8} MB")

    if _byte_to_mb(rootfs_size) > _max_rootfs_size_in_mb():
        print(f"{name} - Warning max. supported root file system size of {_max_rootfs_size_in_mb():>8} MB is reached")

    print(f"{name} - Recommended configured siapp slot size:             {_recommended_siapp_slot_size_in_mb(rootfs_size):>8} MB")
    print(f"{name} - Size of generated siapp installation file:          {_byte_to_mb(siapp_size):>8} MB")
    print(f"{name} - ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
    print(f"{name} - Successfully generated {siapp}")


def generate_container(platform: Platform):
    container_name = BuildArgs.name + '-' + platform.name
    container_file = "Dockerfile"

    # look for the container file relative to this script file or use the current working dir
    if os.path.exists(os.path.join(pathlib.Path(__file__).parent.resolve(),
                                   BuildArgs.dir, container_file)):
        root_path = pathlib.Path(__file__).parent.resolve()
    elif os.path.exists(os.path.join(os.getcwd(), BuildArgs.dir, container_file)):
        root_path = os.getcwd()
    else:
        error_handler(f"File does not exist: {container_file}")

    project_path = os.path.normpath(os.path.join(root_path, BuildArgs.dir))
    build_path = os.path.join(root_path, 'build', BuildArgs.name + '-' + BuildArgs.version)

    _initialize_directory(build_path)
    remove_container(container_name, True)

    _copy_if_exists(os.path.join(project_path, 'cmd'), os.path.join(build_path, 'tmp', 'cmd'))
    _copy_if_exists(os.path.join(project_path, 'app-doc'), os.path.join(build_path, 'tmp', 'app-doc'))

    rootfs_size = _create_rootfs_container(project_path,
                                           build_path,
                                           container_name,
                                           BuildArgs.version,
                                           platform)
    if rootfs_size <= 0:
        error_handler("Could not read rootfs file size!")

    _create_oci_file(project_path, build_path, container_name)
    _create_meta_info_file(build_path, container_name, rootfs_size, platform)

    siapp_size = _package_siapp(build_path, container_name)
    if siapp_size <= 0:
        error_handler("Could not read siapp file size!")

    shutil.rmtree(os.path.join(build_path, 'tmp'))

    _print_result(siapp_size, rootfs_size,
                  str(os.path.join(build_path, container_name)))


if __name__ == "__main__":
    parse_arguments('build')
    init_multiarch_qemu()
    for platform in BuildArgs.platforms:
        generate_container(platform)
